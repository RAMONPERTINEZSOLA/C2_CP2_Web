name: Email on Low Stock

on:
  push:
    branches: [ main ]
    paths:
      - 'docs/stock.csv'        # <-- ruta correcta del CSV
  workflow_dispatch:

env:
  STOCK_PATH: docs/stock.csv    # <-- ruta correcta del CSV
  # Opcional: llindar per defecte si el CSV no porta minStock
  DEFAULT_MIN_STOCK: "2"

jobs:
  check-and-email:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Detect low stock and build email body
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          CSV="${{ env.STOCK_PATH }}"
          if [ ! -f "$CSV" ]; then
            echo "CSV not found at $CSV" >&2
            echo "count=0" >> "$GITHUB_OUTPUT"
            printf "Stock file not found: %s\n" "$CSV" > email_body.txt
            exit 0
          fi

          # Generem un informe simple interpretant 6 columnes:
          # 0:drawerCode, 1:stockQty, 2:productName, 3:productCode, 4:description, 5:minStock(opcional)
          # Si el CSV no té capçalera, igualment funciona.
          python3 - << 'PY'
import csv, os, sys

csv_path = os.environ.get("STOCK_PATH", "docs/stock.csv")
default_min = int(os.environ.get("DEFAULT_MIN_STOCK","2"))

rows = []
with open(csv_path, newline='', encoding='utf-8') as f:
    sniffer = csv.Sniffer()
    sample = f.read(4096)
    f.seek(0)
    has_header = sniffer.has_header(sample)
    reader = csv.reader(f)
    if has_header:
        header = next(reader, [])
    for r in reader:
        if not r: 
            continue
        # Normalitza longitud
        r = (r + [""]*6)[:6]
        drawer, qty, pname, pcode, desc, minsto = r
        # Sanititza valors
        def to_int(x, fallback=0):
            try:
                return int(str(x).strip())
            except:
                return fallback
        qty_i = to_int(qty, fallback=-1) # -1 si buit
        min_i = to_int(minsto, fallback=default_min)

        # Marca low-stock només si qty és >=0 i <= min
        if qty_i >= 0 and qty_i <= min_i:
            rows.append({
                "drawerCode": drawer.strip(),
                "stockQty": qty_i,
                "minStock": min_i,
                "productName": pname.strip(),
                "productCode": pcode.strip(),
                "description": desc.strip(),
            })

# Escriu cos del correu
with open("email_body.txt","w",encoding="utf-8") as out:
    if not rows:
        out.write("✅ No low-stock items detected.\n")
    else:
        out.write("⚠️ Low stock detected on the following items:\n\n")
        for i, r in enumerate(rows, 1):
            out.write(f"{i}. {r['drawerCode']} — qty: {r['stockQty']} (min: {r['minStock']})\n")
            if r['productName']:
                out.write(f"   name: {r['productName']}\n")
            if r['productCode']:
                out.write(f"   code: {r['productCode']}\n")
            if r['description']:
                out.write(f"   desc: {r['description']}\n")
            out.write("\n")

# Exponeix recompte com a sortida del pas
count = len(rows)
print(f"::set-output name=count::{count}")  # compat retro, tot seguit fem GITHUB_OUTPUT
PY

          # Exporta 'count' també a GITHUB_OUTPUT (mètode modern)
          COUNT=$(grep -c '^⚠️\|^1\.' -n email_body.txt || true)
          # Si el cos diu "No low-stock", forcem 0
          if grep -q "No low-stock items detected" email_body.txt; then COUNT=0; fi
          echo "count=$COUNT" >> "$GITHUB_OUTPUT"

      - name: Send email (SMTP)
        if: steps.detect.outputs.count != '0'
        uses: dawidd6/action-send-mail@v3
        with:
          server_address: ${{ secrets.SMTP_SERVER }}
          server_port: ${{ secrets.SMTP_PORT }}
          username: ${{ secrets.SMTP_USERNAME }}
          password: ${{ secrets.SMTP_PASSWORD }}
          subject: "Low Stock Alert — ${{ github.repository }}"
          from: ${{ secrets.FROM_EMAIL }}
          to: ${{ secrets.TO_EMAILS || secrets.TO_EMAIL }}
          # Si el teu servidor és 587, posa 'secure: false'
          secure: ${{ secrets.SMTP_SECURE || 'false' }}
          body: file:email_body.txt
